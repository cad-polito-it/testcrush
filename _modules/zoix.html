<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>zoix &#8212; TestCrush 0.5.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=2bf1fcf8" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=7414fd2b" />
    
    <script src="../_static/documentation_options.js?v=1dd76d02"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <link rel="icon" href="../_static/favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TestCrush 0.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">zoix</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for zoix</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python3</span>
<span class="c1"># SPDX-License-Identifier: MIT</span>

<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">pathlib</span>

<span class="kn">from</span> <span class="nn">testcrush.utils</span> <span class="kn">import</span> <span class="n">get_logger</span><span class="p">,</span> <span class="n">to_snake_case</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">()</span>


<div class="viewcode-block" id="Compilation">
<a class="viewcode-back" href="../zoix.html#zoix.Compilation">[docs]</a>
<span class="k">class</span> <span class="nc">Compilation</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Statuses for the VCS compilation of HDL sources.&quot;&quot;&quot;</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="s2">&quot;ERROR&quot;</span>  <span class="c1"># stderr contains text</span>
    <span class="n">SUCCESS</span> <span class="o">=</span> <span class="s2">&quot;SUCCESS&quot;</span>  <span class="c1"># None of the above</span></div>



<div class="viewcode-block" id="LogicSimulation">
<a class="viewcode-back" href="../zoix.html#zoix.LogicSimulation">[docs]</a>
<span class="k">class</span> <span class="nc">LogicSimulation</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Statuses for the simv logic simulation of a given program.&quot;&quot;&quot;</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="s2">&quot;TIMEOUT&quot;</span>  <span class="c1"># Endless loop</span>
    <span class="n">SIM_ERROR</span> <span class="o">=</span> <span class="s2">&quot;ERROR&quot;</span>  <span class="c1"># stderr contains text</span>
    <span class="n">SUCCESS</span> <span class="o">=</span> <span class="s2">&quot;SUCCESS&quot;</span>  <span class="c1"># None of the above</span></div>



<span class="k">class</span> <span class="nc">LogicSimulationException</span><span class="p">(</span><span class="ne">BaseException</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Custom exception for the simv logic simulation.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s2">&quot;Error during VC Logic Simulation&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>


<div class="viewcode-block" id="FaultSimulation">
<a class="viewcode-back" href="../zoix.html#zoix.FaultSimulation">[docs]</a>
<span class="k">class</span> <span class="nc">FaultSimulation</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Statuses for the Z01X fault simulation.&quot;&quot;&quot;</span>
    <span class="n">TIMEOUT</span> <span class="o">=</span> <span class="s2">&quot;TIMEOUT&quot;</span>  <span class="c1"># Wall-clock</span>
    <span class="n">FSIM_ERROR</span> <span class="o">=</span> <span class="s2">&quot;ERROR&quot;</span>  <span class="c1"># stderr contains text</span>
    <span class="n">SUCCESS</span> <span class="o">=</span> <span class="s2">&quot;SUCCESS&quot;</span>  <span class="c1"># None of the above</span></div>



<div class="viewcode-block" id="Fault">
<a class="viewcode-back" href="../zoix.html#zoix.Fault">[docs]</a>
<span class="k">class</span> <span class="nc">Fault</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic representation of a **prime** fault</span>

<span class="sd">    Each prime fault has two static attributes which are:</span>
<span class="sd">    -``equivalent_faults`` (int): Corresponds to the total number of faults equivalent to this fault. Defaults to 1 i.e.</span>
<span class="sd">    itself.</span>
<span class="sd">    -``equivalent_to`` (Fault): A reference to the primary fault with which the current fault is equivalent. If the</span>
<span class="sd">    current fault is prime. Defaults to ``None``.</span>

<span class="sd">    When a fault is constructed it corresponds to a prime fault. It is up to the user to resolve any fault equivalence</span>
<span class="sd">    by modifying the aforementioned attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">fault_attributes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s1">&#39;Fault&#39;</span><span class="p">:</span>

        <span class="k">for</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">fault_attributes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_faults</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_to</span><span class="p">:</span> <span class="n">Fault</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                          <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;equivalent_faults&quot;</span><span class="p">,</span> <span class="s2">&quot;equivalent_to&quot;</span><span class="p">))</span>  <span class="c1"># Avoid recursive reprs</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">attrs</span><span class="si">}</span><span class="s1">)&#39;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                         <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;equivalent_faults&quot;</span><span class="p">,</span> <span class="s2">&quot;equivalent_to&quot;</span><span class="p">))</span>  <span class="c1"># Avoid recursive reprs</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Fault</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span>

        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Fault.set">
<a class="viewcode-back" href="../zoix.html#zoix.Fault.set">[docs]</a>
    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fault.get">
<a class="viewcode-back" href="../zoix.html#zoix.Fault.get">[docs]</a>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generic getter method for arbitrary attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            attribute (str): The requested attribute of the fault.</span>
<span class="sd">            default (str | None): A default value to be used as a guard.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str | Any: The fault attribute. If no cast has been performed on</span>
<span class="sd">            the attribute then the default type is ``str``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">),</span> <span class="n">default</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fault.cast_attribute">
<a class="viewcode-back" href="../zoix.html#zoix.Fault.cast_attribute">[docs]</a>
    <span class="k">def</span> <span class="nf">cast_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="nb">callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Casts the type of the internal attribute</span>

<span class="sd">        Args:</span>
<span class="sd">            attribute (str): The requested attribute of the fault to be casted.</span>
<span class="sd">            func (callable): A function to cast the fault attribute.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If the requested attribute does not exist.</span>
<span class="sd">            ValueError: If the cast cannot be performed e.g., when</span>
<span class="sd">                       ``int(&#39;a&#39;)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">attribute</span> <span class="o">=</span> <span class="n">attribute</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attribute</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attribute</span><span class="p">))</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attribute</span><span class="si">}</span><span class="s2"> not a member of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unable to cast to </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s2"> of attribute </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">attribute</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Fault.is_prime">
<a class="viewcode-back" href="../zoix.html#zoix.Fault.is_prime">[docs]</a>
    <span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the fault is a prime fault, i.e., is not equivalent to any other fault.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if fault is prime. False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equivalent_to</span> <span class="ow">is</span> <span class="kc">None</span></div>
</div>



<div class="viewcode-block" id="TxtFaultReport">
<a class="viewcode-back" href="../zoix.html#zoix.TxtFaultReport">[docs]</a>
<span class="k">class</span> <span class="nc">TxtFaultReport</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages the VC-Z01X text report.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;fault_report_path&quot;</span><span class="p">,</span> <span class="s2">&quot;fault_report&quot;</span><span class="p">,</span> <span class="s2">&quot;fault_list&quot;</span><span class="p">,</span> <span class="s2">&quot;status_groups&quot;</span><span class="p">,</span> <span class="s2">&quot;coverage&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fault_report</span><span class="p">:</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;TxtFaultReport&quot;</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fault_report_path</span> <span class="o">=</span> <span class="n">fault_report</span>  <span class="c1"># Store the path, but don&#39;t read the file yet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fault_report</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fault_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status_groups</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fault_report_path</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_load_fault_report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load the fault report from the file.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_report_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fault report file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fault_report_path</span><span class="si">}</span><span class="s2"> not found.&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fault_report_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fault_report</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_parse_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse the required sections from the fault report.&quot;&quot;&quot;</span>
        <span class="c1"># Ensure the fault report is loaded before parsing</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_report</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fault report is not loaded.&quot;</span><span class="p">)</span>

        <span class="c1"># Lazy import to avoid circular dependencies</span>
        <span class="kn">from</span> <span class="nn">testcrush.grammars.transformers</span> <span class="kn">import</span> <span class="n">FaultReportTransformerFactory</span>

        <span class="n">factory</span> <span class="o">=</span> <span class="n">FaultReportTransformerFactory</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;StatusGroups&quot;</span><span class="p">,</span> <span class="s2">&quot;Coverage&quot;</span><span class="p">,</span> <span class="s2">&quot;FaultList&quot;</span><span class="p">]:</span>
            <span class="n">parser</span> <span class="o">=</span> <span class="n">factory</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">raw_section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># section doesn&#39;t exist</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_snake_case</span><span class="p">(</span><span class="n">section</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parsing </span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_snake_case</span><span class="p">(</span><span class="n">section</span><span class="p">),</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">raw_section</span><span class="p">))</span>

<div class="viewcode-block" id="TxtFaultReport.update">
<a class="viewcode-back" href="../zoix.html#zoix.TxtFaultReport.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update and parse all sections once the fault report file is available.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_fault_report</span><span class="p">()</span>  <span class="c1"># Read the file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_sections</span><span class="p">()</span>  <span class="c1"># Parse all sections</span></div>


<div class="viewcode-block" id="TxtFaultReport.extract">
<a class="viewcode-back" href="../zoix.html#zoix.TxtFaultReport.extract">[docs]</a>
    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts a section of the fault report.</span>

<span class="sd">        Args:</span>
<span class="sd">            section (str): The case-sensitive section name. E.g., ``Coverage``, ``FaultList``</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: A newline-joined string of the extracted section (section name included).</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If ``section`` does not exist in the fault report.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extracted_lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Loop control</span>
        <span class="n">section_found</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">brackets_cc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_report</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">line</span> <span class="ow">and</span> <span class="s2">&quot;{&quot;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found Section </span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="n">line</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">section_found</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">section_found</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">section_found</span><span class="p">:</span>

                <span class="k">if</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">brackets_cc</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="s1">&#39;}&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">brackets_cc</span> <span class="o">-=</span> <span class="mi">1</span>

                <span class="n">extracted_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">fr</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">brackets_cc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">section_found</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested section </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> not found!&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Requested section </span><span class="se">\&quot;</span><span class="si">{</span><span class="n">section</span><span class="si">}</span><span class="se">\&quot;</span><span class="s2"> not found!&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">extracted_lines</span><span class="p">)</span></div>


<div class="viewcode-block" id="TxtFaultReport.compute_coverage">
<a class="viewcode-back" href="../zoix.html#zoix.TxtFaultReport.compute_coverage">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">requested_formula</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manually computes the coverage based on the current fault report.</span>

<span class="sd">        Args:</span>
<span class="sd">            requested_formula (str, optional): The name of the coverage formula from the ``Coverage {}`` section of the</span>
<span class="sd">                                               fault report. Defaults to None.</span>
<span class="sd">            precision (int, optional): The requested float precision. Defaults to 4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, float] | float: If no formula name is provided, returns a dictionary mapping formula names to</span>
<span class="sd">            their corresponding evaluated coverage values as floats. If a formula name is specified, returns only</span>
<span class="sd">            the evaluated value for that formula.</span>

<span class="sd">        .. todo::</span>
<span class="sd">            * Implement default Test/Fault coverage computation per-Z01X if no ``Coverage{}`` section exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computing coverage </span><span class="si">{</span><span class="n">requested_formula</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

        <span class="n">retval</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">fault_statusses</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fault</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fault_list</span><span class="p">:</span>

            <span class="n">status</span> <span class="o">=</span> <span class="n">fault</span><span class="o">.</span><span class="n">fault_status</span>

            <span class="k">if</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">fault_statusses</span><span class="p">:</span>
                <span class="n">fault_statusses</span><span class="p">[</span><span class="n">status</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fault_statusses</span><span class="p">[</span><span class="n">status</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">status_groups</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status_groups</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">group</span><span class="p">,</span> <span class="n">statuses</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">status_groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">status_groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">statuses</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">status</span> <span class="ow">in</span> <span class="n">fault_statusses</span><span class="p">:</span>

                        <span class="n">status_groups</span><span class="p">[</span><span class="n">group</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fault_statusses</span><span class="p">[</span><span class="n">status</span><span class="p">]</span>

        <span class="c1"># We expect that if a coverage formula is specified</span>
        <span class="c1"># i.e., Coverage{} exists, then there  may  be some</span>
        <span class="c1"># variables there which may not  exist in  statuses</span>
        <span class="c1"># or groups. Hence we must set them to 0.</span>
        <span class="n">non_present</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">formula_name</span><span class="p">,</span> <span class="n">formula</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coverage</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="k">for</span> <span class="n">status_or_group</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;[A-Z]</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">formula</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">status_or_group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fault_statusses</span> <span class="ow">and</span> <span class="n">status_or_group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">status_groups</span><span class="p">:</span>

                        <span class="n">non_present</span><span class="p">[</span><span class="n">status_or_group</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="n">retval</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">formula_name</span><span class="p">,</span>
                               <span class="nb">round</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="p">{</span><span class="o">**</span><span class="n">fault_statusses</span><span class="p">,</span> <span class="o">**</span><span class="n">status_groups</span><span class="p">,</span> <span class="o">**</span><span class="n">non_present</span><span class="p">}),</span>
                                     <span class="n">precision</span><span class="p">)))</span>

        <span class="c1"># Else: TODO: Implement default coverage computation according to manual</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">retval</span><span class="p">)[</span><span class="n">requested_formula</span><span class="p">]</span> <span class="k">if</span> <span class="n">requested_formula</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">retval</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ZoixInvoker">
<a class="viewcode-back" href="../zoix.html#zoix.ZoixInvoker">[docs]</a>
<span class="k">class</span> <span class="nc">ZoixInvoker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper class to be used in handling calls to VCS-Z01X.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ZoixInvoker&quot;</span><span class="p">:</span>
        <span class="o">...</span>

<div class="viewcode-block" id="ZoixInvoker.execute">
<a class="viewcode-back" href="../zoix.html#zoix.ZoixInvoker.execute">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="n">instruction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Executes a **bash** instruction and returns the ``stdout`` and ``stderr`` responses as a tuple.</span>

<span class="sd">        Args:</span>
<span class="sd">            instruction (str): The bash instruction to be executed.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple(str, str): The stdout (index 0) and the stderr (index 1)</span>
<span class="sd">            as strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Executing </span><span class="si">{</span><span class="n">instruction</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s2">&quot;/bin/bash&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="n">instruction</span><span class="p">],</span>
                              <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
                              <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">process</span><span class="p">:</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="n">process</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span>

            <span class="k">except</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">TimeoutExpired</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TIMEOUT during the execution of:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">instruction</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">process</span><span class="o">.</span><span class="n">kill</span><span class="p">()</span>
                <span class="k">return</span> <span class="s2">&quot;TimeoutExpired&quot;</span><span class="p">,</span> <span class="s2">&quot;TimeoutExpired&quot;</span></div>


<div class="viewcode-block" id="ZoixInvoker.compile_sources">
<a class="viewcode-back" href="../zoix.html#zoix.ZoixInvoker.compile_sources">[docs]</a>
    <span class="k">def</span> <span class="nf">compile_sources</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">instructions</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Compilation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs compilation of HDL files</span>

<span class="sd">        Args:</span>
<span class="sd">            instructions (str): A variadic number of bash shell instructions</span>

<span class="sd">        Returns:</span>
<span class="sd">            Compilation: A status Enum to signify the success or failure of the compilation.</span>

<span class="sd">                - ERROR: if any text was found in the ``stderr`` stream during the execution of an instruction.</span>
<span class="sd">                - SUCCESS: otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">compilation_status</span> <span class="o">=</span> <span class="n">Compilation</span><span class="o">.</span><span class="n">SUCCESS</span>

        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>

            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">stderr</span><span class="p">:</span>

                <span class="n">compilation_status</span> <span class="o">=</span> <span class="n">Compilation</span><span class="o">.</span><span class="n">ERROR</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">compilation_status</span></div>


<div class="viewcode-block" id="ZoixInvoker.logic_simulate">
<a class="viewcode-back" href="../zoix.html#zoix.ZoixInvoker.logic_simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">logic_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">instructions</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">LogicSimulation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs logic simulation of user-defined firmware and captures the test application time.</span>

<span class="sd">        A timeout value must be specified in order to avoid endless loops that will hang the program. There are</span>
<span class="sd">        two important kwargs that the user must specify. The success regexp and the tat regexp. During a logic</span>
<span class="sd">        simulation, the simulator typically stops when a ``$finish`` call is met. However, in a non-trivial DUT case</span>
<span class="sd">        like e.g., a processor, there are many things that may go wrong like for instance an out-of-bounds read or</span>
<span class="sd">        write from/to a memory. In that case, it is up to the designer to handle accordingly the situation e.g., issue</span>
<span class="sd">        a ``$fatal`` call. Which means, that in order to be accurate and know whether the logic simulation terminates</span>
<span class="sd">        gracefully, some sort of ``$display`` must be specified -or- at least the ``$finish`` statement must be invoked</span>
<span class="sd">        from the correct place. For this reason, the success regexp is required in order to know that not only the logic</span>
<span class="sd">        simulation ended but that it also ended without causing any kind of violation in the DUT.</span>

<span class="sd">        When it comes to the tat regexp, this can be either a custom message again issued by the testbench or the time</span>
<span class="sd">        of the simulation that the correct ``$finish`` statement was issued. It is up to the user to specify it. However</span>
<span class="sd">        in order for the logic simulation to be considerred successful the success regexp AND the tat regexp must match</span>
<span class="sd">        something.</span>


<span class="sd">        Args:</span>
<span class="sd">            instructions (str): A variadic number of bash instructions</span>
<span class="sd">            kwargs: User-defined options needed for the evaluation of the result of the logic simulation.</span>
<span class="sd">                    These options are:</span>

<span class="sd">                - **timeout** (float): A timeout in **seconds** to be used for **each** of the executed logic</span>
<span class="sd">                  simulation instructions.</span>

<span class="sd">                - **simulation_ok_regex** (re.Pattern): A regular expression used for matching in every line of the</span>
<span class="sd">                  ``stdout`` stream to mark the successful completion of the logic simulation.</span>

<span class="sd">                - **test_application_time_regex** (re.Pattern): A regular expression used to match the line that reports</span>
<span class="sd">                  the test application time from the simulator.</span>

<span class="sd">                - **test_application_time_regex_group_no** (int): The index of the capture group in the custom regular</span>
<span class="sd">                  expression for the TaT value. Default is 1, corresponding to the ``success_regexp`` group.</span>

<span class="sd">                - **tat_value** (list): An **empty** list to store the TaT value after being successfully matched with</span>
<span class="sd">                  ``success_regexp``. The list is used to mimic a pass-by-reference.</span>

<span class="sd">        Returns:</span>
<span class="sd">            LogicSimulation: A status Enum which is:</span>

<span class="sd">                - TIMEOUT: if user defined timeout has been triggered.</span>
<span class="sd">                - SIM_ERROR: if any text was found in the ``stderr`` stream during the execution of an instruction.</span>
<span class="sd">                - SUCCESS: if the halting regexp matched text from the ``stdout`` stream.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;timeout&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># The default regexp catches the line:</span>
        <span class="c1"># $finish at simulation time  XXXXXXYs</span>
        <span class="c1"># where X = a digit and Y = time unit.</span>
        <span class="c1"># Capturing of the simulation duration</span>
        <span class="c1"># done for possible TaT purposes. NOTE</span>
        <span class="c1"># that it is advised that BOTH regular</span>
        <span class="c1"># expressions ARE specified and   that</span>
        <span class="c1"># the default value is not  used. That</span>
        <span class="c1"># is because it may be that the TB may</span>
        <span class="c1"># have &gt;=1 $finish call locations e.g.</span>
        <span class="c1"># on an out-of-bounds read/write case.</span>
        <span class="c1"># Hence, be as accurate as possible!!!</span>
        <span class="n">default_regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\$finish[^0-9]+([0-9]+)[m|u|n|p]s&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span><span class="p">)</span>

        <span class="n">success_regexp</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;simulation_ok_regex&quot;</span><span class="p">,</span> <span class="n">default_regexp</span><span class="p">)</span>
        <span class="n">tat_regexp</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;test_application_time_regex&quot;</span><span class="p">,</span> <span class="n">default_regexp</span><span class="p">)</span>

        <span class="c1"># By default, a single capturing  group</span>
        <span class="c1"># is expected in the regexp, which maps</span>
        <span class="c1"># to the TaT value. If a custom  regexp</span>
        <span class="c1"># is provided however, with &gt;1  groups,</span>
        <span class="c1"># then the user must specify  which  is</span>
        <span class="c1"># the expected capture group.</span>
        <span class="n">tat_capture_group</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;test_application_time_regex_group_no&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># An empty mutable container is expected</span>
        <span class="c1"># to store the TaT  value  matched  from</span>
        <span class="c1"># the regexp. It is used  like  that  to</span>
        <span class="c1"># mimic  pass-by-reference and not alter</span>
        <span class="c1"># the function&#39;s return value.</span>
        <span class="n">tat_value</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tat_value&quot;</span><span class="p">,</span> <span class="p">[])</span>

        <span class="n">simulation_status</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Loop control flags</span>
        <span class="n">exit_success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tat_success</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>

            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">stderr</span> <span class="ow">and</span> <span class="n">stderr</span> <span class="o">!=</span> <span class="s2">&quot;TimeoutExpired&quot;</span><span class="p">:</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during execution of </span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="se">\n\</span>
<span class="s2">                ------[STDERR STREAM]------</span><span class="se">\n\</span>
<span class="s2">                </span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stderr</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="si">}</span><span class="se">\n\</span>
<span class="s2">                ---------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">simulation_status</span> <span class="o">=</span> <span class="n">LogicSimulation</span><span class="o">.</span><span class="n">SIM_ERROR</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">stderr</span> <span class="o">==</span> <span class="n">stdout</span> <span class="o">==</span> <span class="s2">&quot;TimeoutExpired&quot;</span><span class="p">:</span>

                <span class="n">simulation_status</span> <span class="o">=</span> <span class="n">LogicSimulation</span><span class="o">.</span><span class="n">TIMEOUT</span>
                <span class="k">break</span>

            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stdout</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Exit success</span>
                <span class="n">success_match</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">success_regexp</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">success_match</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exit Success: </span><span class="si">{</span><span class="n">success_match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">exit_success</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># TaT matching</span>
                <span class="n">tat_match</span><span class="p">:</span> <span class="n">re</span><span class="o">.</span><span class="n">Match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">tat_regexp</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tat_match</span><span class="p">:</span>

                    <span class="n">test_application_time</span> <span class="o">=</span> <span class="n">tat_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="n">tat_capture_group</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tat_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">test_application_time</span><span class="p">))</span>
                        <span class="n">tat_success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">LogicSimulationException</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Test application time was not correctly captured </span><span class="se">\</span>
<span class="si">{</span><span class="n">test_application_time</span><span class="si">=}</span><span class="s2"> and could not be converted to an integer. Perhaps there is something wrong with your regular </span><span class="se">\</span>
<span class="s2">expression &#39;</span><span class="si">{</span><span class="n">tat_regexp</span><span class="si">}</span><span class="s2">&#39; ?&quot;</span><span class="p">)</span>

                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TaT Captured: </span><span class="si">{</span><span class="n">tat_match</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">tat_success</span> <span class="ow">and</span> <span class="n">exit_success</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">tat_success</span> <span class="ow">and</span> <span class="n">exit_success</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation Success! </span><span class="si">{</span><span class="n">exit_success</span><span class="si">=}</span><span class="s2"> and </span><span class="si">{</span><span class="n">tat_success</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">simulation_status</span> <span class="o">=</span> <span class="n">LogicSimulation</span><span class="o">.</span><span class="n">SUCCESS</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="n">tat_success</span> <span class="ow">and</span> <span class="n">exit_success</span><span class="p">)</span> <span class="ow">and</span> <span class="n">simulation_status</span> <span class="o">!=</span> <span class="n">LogicSimulation</span><span class="o">.</span><span class="n">TIMEOUT</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation Failed! </span><span class="si">{</span><span class="n">exit_success</span><span class="si">=}</span><span class="s2"> and </span><span class="si">{</span><span class="n">tat_success</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">simulation_status</span> <span class="o">=</span> <span class="n">LogicSimulation</span><span class="o">.</span><span class="n">SIM_ERROR</span>

        <span class="k">return</span> <span class="n">simulation_status</span></div>


<div class="viewcode-block" id="ZoixInvoker.fault_simulate">
<a class="viewcode-back" href="../zoix.html#zoix.ZoixInvoker.fault_simulate">[docs]</a>
    <span class="k">def</span> <span class="nf">fault_simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">instructions</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FaultSimulation</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs fault simulation of a user-defined firmware.</span>

<span class="sd">        Args:</span>
<span class="sd">            instructions (str): A variadic number of shell instructions</span>
<span class="sd">                                to invoke Z01X.</span>
<span class="sd">            kwargs: User-defined options for fault simulation control.</span>

<span class="sd">                - timeout (float): A timeout in **seconds** for each fsim</span>
<span class="sd">                  instruction.</span>
<span class="sd">                - allow_regexs (list[re.Pattern]): Series of regexps to look for in</span>
<span class="sd">                  ``stderr`` and allow continuation without raising any error</span>
<span class="sd">                  messages.</span>

<span class="sd">        Returns:</span>
<span class="sd">            FaultSimulation: A status Enum which is:</span>

<span class="sd">                - TIMEOUT: if the timeout kwarg was provided and some</span>
<span class="sd">                  instruction exceeded it.</span>
<span class="sd">                - FSIM_ERROR: if the ``stderr`` stream contains text during the</span>
<span class="sd">                  execution of an instruction.</span>
<span class="sd">                - SUCCESS: if none of the above.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fault_simulation_status</span> <span class="o">=</span> <span class="n">FaultSimulation</span><span class="o">.</span><span class="n">SUCCESS</span>

        <span class="n">timeout</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;timeout&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">allow</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;allow_regexs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cmd</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>

            <span class="n">stdout</span><span class="p">,</span> <span class="n">stderr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="n">timeout</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">stderr</span> <span class="ow">and</span> <span class="n">stderr</span> <span class="o">!=</span> <span class="s2">&quot;TimeoutExpired&quot;</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">allow</span><span class="p">:</span>

                    <span class="n">continue_execution</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">for</span> <span class="n">regexp</span> <span class="ow">in</span> <span class="n">allow</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">regexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">stderr</span><span class="p">):</span>

                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Allowing message </span><span class="si">{</span><span class="n">regexp</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">stderr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">continue_execution</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>

                    <span class="k">if</span> <span class="n">continue_execution</span><span class="p">:</span>

                        <span class="k">continue</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error during execution of </span><span class="si">{</span><span class="n">cmd</span><span class="si">}</span><span class="se">\n\</span>
<span class="s2">                ------[STDERR STREAM]------</span><span class="se">\n\</span>
<span class="s2">                </span><span class="si">{</span><span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">stderr</span><span class="o">.</span><span class="n">splitlines</span><span class="p">(</span><span class="n">keepends</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span><span class="si">}</span><span class="se">\n\</span>
<span class="s2">                ---------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">fault_simulation_status</span> <span class="o">=</span> <span class="n">FaultSimulation</span><span class="o">.</span><span class="n">FSIM_ERROR</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">stderr</span> <span class="o">==</span> <span class="n">stdout</span> <span class="o">==</span> <span class="s2">&quot;TimeoutExpired&quot;</span><span class="p">:</span>

                <span class="n">fault_simulation_status</span> <span class="o">=</span> <span class="n">FaultSimulation</span><span class="o">.</span><span class="n">TIMEOUT</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">fault_simulation_status</span></div>
</div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table of Contents</a></h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../asm.html">Assembly File Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zoix.html">Z01X Related</a></li>
<li class="toctree-l1"><a class="reference internal" href="../grammar.html">Grammars and Parsing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../a0.html">A0 Algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">Miscellanous Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../config.html">TestCrush Configuration</a></li>
</ul>

<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="Related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">TestCrush 0.5.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">zoix</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Nikolaos I. Deligiannis.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    </div>
  </body>
</html>